<?php/** * @file * Contains \Drupal\graphql\TypeResolver\Specialized\EntityTypeResolver. */namespace Drupal\graphql\TypeResolver\Specialized;use Drupal\Core\Entity\EntityInterface;use Drupal\Core\Entity\EntityManagerInterface;use Drupal\Core\Entity\Plugin\DataType\EntityAdapter;use Drupal\Core\Entity\TypedData\EntityDataDefinitionInterface;use Drupal\Core\Field\FieldDefinitionInterface;use Drupal\Core\Field\FieldItemListInterface;use Drupal\Core\TypedData\ComplexDataDefinitionInterface;use Drupal\Core\TypedData\DataDefinitionInterface;use Drupal\Core\TypedData\TypedDataInterface;use Drupal\Core\TypedData\TypedDataManager;use Drupal\graphql\TypeResolver\Generic\ComplexDataTypeResolver;use Drupal\graphql\TypeResolverInterface;use Fubhy\GraphQL\Language\Node;use Fubhy\GraphQL\Type\Definition\Types\InterfaceType;use Fubhy\GraphQL\Type\Definition\Types\ListModifier;use Fubhy\GraphQL\Type\Definition\Types\NonNullModifier;use Fubhy\GraphQL\Type\Definition\Types\ObjectType;/** * Resolves typed data types. */class EntityTypeResolver extends ComplexDataTypeResolver {  /**   * Static cache of resolved schema object types.   *   * @var array   */  protected $objectCache = [];  /**   * Static cache of resolved schema interface types.   *   * @var array   */  protected $interfaceCache = [];  /**   * The typed data manager service.   *   * @var \Drupal\Core\TypedData\TypedDataManager   */  protected $typedDataManager;  /**   * The entity manager service.   *   * @var \Drupal\Core\Entity\EntityManagerInterface   */  protected $entityManager;  /**   * Constructs a EntityTypeResolver object.   *   * @param TypeResolverInterface $type_resolver   *   The base type resolver service.   * @param \Drupal\Core\Entity\EntityManagerInterface $entity_manager   *   The entity manager service.   * @param TypedDataManager $typed_data_manager   *   The typed data manager service.   */  public function __construct(TypeResolverInterface $type_resolver, EntityManagerInterface $entity_manager, TypedDataManager $typed_data_manager) {    parent::__construct($type_resolver);    $this->typedDataManager = $typed_data_manager;    $this->entityManager = $entity_manager;  }  /**   * {@inheritdoc}   */  public function applies($type) {    return $type instanceof EntityDataDefinitionInterface;  }  /**   * {@inheritdoc}   */  protected function doResolveRecursive($definition) {    if ($definition instanceof EntityDataDefinitionInterface) {      // We only support content entity types for now.      $entity_type_id = $definition->getEntityTypeId();      foreach ($this->entityManager->getBundleInfo($entity_type_id) as $bundle_name => $bundle_info) {        $this->getEntityBundleObject($entity_type_id, $bundle_name);      }      if ($resolved = $this->getEntityTypeInterface($entity_type_id)) {        return $definition->isRequired() ? new NonNullModifier($resolved) : $resolved;      }    }    return NULL;  }  /**   * @param $entity_type_id   * @param $bundle_name   *   * @return \Fubhy\GraphQL\Type\Definition\Types\ObjectType   */  protected function getEntityBundleObject($entity_type_id, $bundle_name) {    /** @var EntityDataDefinitionInterface $definition */    $definition = $this->typedDataManager->createDataDefinition("entity:$entity_type_id");    $definition->setBundles([$bundle_name]);    $key = $this->getTypeIdentifier($definition);    if (array_key_exists($key, $this->objectCache)) {      return $this->objectCache[$key];    }    // Initialize the static cache entry.    $cache = &$this->objectCache[$key];    if ($fields = $this->getFieldsFromPropertiesOrSchema($definition)) {      $interface = $this->getEntityTypeInterface($entity_type_id);      $cache = new ObjectType($this->getTypeName($definition), $fields, [$interface]);    }    return $cache;  }  /**   * @param $entity_type_id   *   * @return \Fubhy\GraphQL\Type\Definition\Types\InterfaceType   */  protected function getEntityTypeInterface($entity_type_id) {    /** @var EntityDataDefinitionInterface $definition */    $definition = $this->typedDataManager->createDataDefinition("entity:$entity_type_id");    $key = $this->getTypeIdentifier($definition);    if (array_key_exists($key, $this->interfaceCache)) {      return $this->interfaceCache[$key];    }    // Initialize the static cache entry.    $cache = &$this->interfaceCache[$key];    if ($fields = $this->getFieldsFromPropertiesOrSchema($definition)) {      $cache = new InterfaceType($this->getTypeName($definition), $fields, function ($source) {        if ($source instanceof TypedDataInterface) {          if (($entity = $source->getValue()) instanceof EntityInterface) {            return $this->getEntityBundleObject($entity->getEntityType()->id(), $entity->bundle());          }        }        return NULL;      });    }    return $cache;  }  protected function getFieldsFromPropertiesOrSchema(ComplexDataDefinitionInterface $definition) {    /** @var EntityDataDefinitionInterface $definition */    $entity_definition = $this->entityManager->getDefinition($definition->getEntityTypeId());    $entity_implements = class_implements($entity_definition->getClass());    $fields = [];    if (in_array('Drupal\Core\Entity\ContentEntityInterface', $entity_implements)) {      $fields = $this->getFieldsFromProperties($definition);    }    else if (in_array('Drupal\Core\Config\Entity\ConfigEntityInterface', $entity_implements)) {      $fields = $this->getFieldsFromSchema($definition);    }    // TODO Properly assign references to the interface/bundle.    $entity_type_id = $definition->getEntityTypeId();    $target_definition = $this->typedDataManager->createDataDefinition("entity:$entity_type_id");    $references_map = $this->getReferencesMap();    $references = isset($references_map[$entity_type_id]) ? $references_map[$entity_type_id] : [];    $referencing_types = [];    $type_name = $this->getTypeName($target_definition);    foreach ($references as $origin => $reference_fields) {      $origin_definition = $this->typedDataManager->createDataDefinition("entity:$origin");      if (!$referencing_type = $this->doResolveRecursive($origin_definition)) {        continue;      }      $referencing_fields = [];      foreach ($reference_fields as $reference_field) {        $referencing_fields[$reference_field] = [          'type' => new NonNullModifier(new ListModifier($referencing_type)),          'resolve' => [__CLASS__, 'resolveReferencingEntities'],        ];      }      if (empty($referencing_fields)) {        continue;      }      $origin_name = $this->getTypeName($origin_definition);      $type = new ObjectType("{$type_name}ReferencingTypes{$origin_name}", $referencing_fields);      $referencing_types[$origin] = [        'type' => $type,        'resolve' => function ($source) use ($origin) {          return [$origin, $source];        }      ];    }    if (!empty($referencing_types)) {      $type = new ObjectType("{$type_name}ReferencingTypes", $referencing_types);      $fields['references'] = [        'type' => $type,        'resolve' => function ($source) {          return $source;        }      ];    }    return $fields;  }  /**   * @param ComplexDataDefinitionInterface $definition   *   * @return array   */  protected function getFieldsFromProperties(ComplexDataDefinitionInterface $definition) {    $fields = array_filter(array_map(function (DataDefinitionInterface $property) use ($definition) {      return $this->getFieldFromProperty($definition, $property);    }, $definition->getPropertyDefinitions()));    return $fields;  }  /**   * @param ComplexDataDefinitionInterface $definition   *   * @return array   */  protected function getFieldsFromSchema(ComplexDataDefinitionInterface $definition) {    // TODO Add typed config schema based resolution of config entities.    $fields = [];    return $fields;  }  /**   * @param \Drupal\Core\TypedData\ComplexDataDefinitionInterface $definition   * @param \Drupal\Core\TypedData\DataDefinitionInterface $property   *   * @return array   */  protected function getFieldFromProperty(ComplexDataDefinitionInterface $definition, DataDefinitionInterface $property) {    if (!($property instanceof FieldDefinitionInterface)) {      // Treat everything except field definitions normally.      return parent::getFieldFromProperty($definition, $property);    }    $storage = $property->getFieldStorageDefinition();    $required = $property->isRequired();    $multiple = $storage->isMultiple();    if (count($storage->getPropertyNames()) === 1 && $main = $storage->getMainPropertyName()) {      $property = $storage->getPropertyDefinition($main);    }    else {      $property = $property->getItemDefinition();    }    if (!$type = $this->typeResolver->resolveRecursive($property)) {      return FALSE;    }    $type = $multiple ? new ListModifier($type) : $type;    $type = $required ? new NonNullModifier($type) : $type;    return [      'type' => $type,      'resolve' => [__CLASS__, 'resolvePropertyValue'],    ];  }  protected function getReferencesMap() {    if (!isset($this->referencesMap)) {      $this->referencesMap = [];      $reference_fields = $this->entityManager->getFieldMapByFieldType('entity_reference');      foreach ($reference_fields as $origin => $fields) {        $storage_definitions = $this->entityManager->getFieldStorageDefinitions($origin);        $intersection = array_intersect_key($storage_definitions, $fields);        foreach ($intersection as $name => $storage) {          $target = $storage->getSetting('target_type');          $this->referencesMap[$target][$origin][$name] = $name;        }      }    }    return $this->referencesMap;  }  /**   * @param mixed $source   * @param array|NULL $args   * @param mixed $root   * @param \Fubhy\GraphQL\Language\Node $field   *   * @return \Drupal\Core\Field\FieldItemListInterface|mixed|null   * @throws \Drupal\Core\TypedData\Exception\MissingDataException   */  public static function resolvePropertyValue($source, array $args = NULL, $root, Node $field) {    if ($source instanceof EntityAdapter) {      $key = $field->get('name')->get('value');      /** @var FieldItemListInterface $value */      $value = $source->get($key);      $storage = $value->getFieldDefinition()->getFieldStorageDefinition();      $multiple = $storage->isMultiple();      $value = $multiple ? iterator_to_array($value) : [$value->first()];      if (count($storage->getPropertyNames()) === 1 && $main = $storage->getMainPropertyName()) {        $value = array_map(function ($item) use ($main) {          return $item->get($main)->getValue();        }, $value);      }      return $multiple ? $value : reset($value);    }    return NULL;  }  /**   * @param mixed $source   * @param array|NULL $args   * @param mixed $root   * @param \Fubhy\GraphQL\Language\Node $field   *   * @return \Drupal\Core\Field\FieldItemListInterface|mixed|null   * @throws \Drupal\Core\TypedData\Exception\MissingDataException   */  public static function resolveReferencingEntities($source, array $args = NULL, $root, Node $field) {    if (!is_array($source)) {      return NULL;    }    list($type, $adapter) = $source;    if ($adapter instanceof EntityAdapter) {      $key = $field->get('name')->get('value');      $entity_manager = \Drupal::entityManager();      $storage = $entity_manager->getStorage($type);      $query = $storage->getQuery()        ->accessCheck()        ->range(0, 10)        ->condition($key, $adapter->getValue()->id());      if (!$results = $query->execute()) {        return [];      }      $entities = $storage->loadMultiple($results);      foreach ($entities as &$entity) {        $entity = $entity->getTypedData();      }      return $entities;    }    return NULL;  }}